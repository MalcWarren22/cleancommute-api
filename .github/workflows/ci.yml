name: ci

on:
  push:
  pull_request:
  workflow_dispatch:

jobs:
  smoke:
    runs-on: ubuntu-latest

    services:
      mongo:
        image: mongo:6
        ports:
          - 27017:27017
        options: >-
          --health-cmd="mongosh --quiet --eval 'db.runCommand({ ping: 1 }).ok'"
          --health-interval=5s
          --health-timeout=5s
          --health-retries=20

    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Install deps (+ dev tools)
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install ruff black pip-audit

      - name: Compile sources (fast syntax check)
        run: python -m py_compile *.py || true

      - name: Wait for Mongo to be reachable
        run: |
          python - <<'PY'
          import time, sys
          from pymongo import MongoClient
          for _ in range(60):
              try:
                  MongoClient("mongodb://localhost:27017", serverSelectionTimeoutMS=1000).admin.command("ping")
                  print("Mongo is up")
                  sys.exit(0)
              except Exception:
                  time.sleep(1)
          print("Mongo did not come up", file=sys.stderr)
          sys.exit(1)
          PY

      # UPDATED: Smoke test now checks health JSON and uses commute endpoints
      - name: Smoke test with Flask test client
        env:
          # IMPORTANT: include a DB name in the URI so app.py can parse it
          MONGO_URI: "mongodb://localhost:27017/cleancommute_ci"
          PYTHONPATH: ${{ github.workspace }}
        run: |
          python - <<'PY'
          import json, os

          os.environ.setdefault("MONGO_URI", "mongodb://localhost:27017/cleancommute_ci")

          from app import app
          c = app.test_client()

          def J(r):
              return json.loads(r.data.decode("utf-8"))

          # Health should be 200 and include proper JSON with db name
          r = c.get("/api/v1/health")
          assert r.status_code == 200, f"/health -> {r.status_code} {r.data!r}"
          body = J(r)
          assert body.get("status") == "ok", f"bad health body: {body}"
          assert body.get("db") == "cleancommute_ci", f"expected db cleancommute_ci, got {body}"

          # Create a commute (no auth required in new app.py)
          r = c.post("/api/v1/commutes", json={"distance_km": 7.2, "mode": "car", "passengers": 2})
          assert r.status_code == 201, f"create commute -> {r.status_code} {r.data!r}"
          created = J(r)
          assert "kgCO2e" in created and created["kgCO2e"] >= 0, f"bad estimate: {created}"

          # List should contain at least one item
          r = c.get("/api/v1/commutes")
          assert r.status_code == 200, f"list -> {r.status_code}"
          lst = J(r).get("commutes", [])
          assert isinstance(lst, list) and len(lst) >= 1, f"expected 1+ commutes, got {lst}"

          # Clear should succeed
          r = c.post("/api/v1/commutes/clear")
          assert r.status_code == 200, f"clear -> {r.status_code}"

          print("✅ Smoke OK")
          PY

      - name: Style (ruff + black autoformat)
        run: |
          ruff check .
          black .
          echo "✅ Style checks passed (Black autoformatted if needed)."

      - name: Vulnerability scan (pip-audit; non-blocking)
        run: pip-audit -r requirements.txt || true

  deploy_staging:
    name: Deploy to Heroku (staging)
    runs-on: ubuntu-latest
    needs: smoke
    if: github.event_name == 'push' && github.ref == 'refs/heads/staging'
    steps:
      - uses: actions/checkout@v4

      - name: Install Heroku CLI
        run: curl https://cli-assets.heroku.com/install.sh | sh

      - name: Authenticate Heroku
        run: echo "${{ secrets.HEROKU_API_KEY }}" | heroku auth:token

      - name: Push code to Heroku (staging)
        run: git push https://heroku:${{ secrets.HEROKU_API_KEY }}@git.heroku.com/${{ vars.HEROKU_APP_STAGING }}.git HEAD:main

      - name: Health check (staging)
        env:
          HEROKU_APP: ${{ vars.HEROKU_APP_STAGING }}
        run: |
          set -e
          BASE=$(heroku apps:info -a "$HEROKU_APP" | sed -n 's/^Web URL: *//p')
          BASE=${BASE%/}
          URL="${BASE}/api/v1/health"
          echo "Checking $URL"
          for i in {1..45}; do
            code=$(curl -s -o /dev/null -w "%{http_code}" "$URL" || true)
            if [ "$code" = "200" ]; then echo "Healthy ✅"; exit 0; fi
            sleep 2
          done
          echo "Health check failed ❌ (last code: $code) at $URL"; exit 1

  deploy_prod:
    name: Deploy to Heroku (production)
    runs-on: ubuntu-latest
    needs: smoke
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    steps:
      - uses: actions/checkout@v4

      - name: Install Heroku CLI
        run: curl https://cli-assets.heroku.com/install.sh | sh

      - name: Authenticate Heroku
        run: echo "${{ secrets.HEROKU_API_KEY }}" | heroku auth:token

      - name: Push code to Heroku (prod)
        run: git push https://heroku:${{ secrets.HEROKU_API_KEY }}@git.heroku.com/${{ vars.HEROKU_APP_PROD }}.git HEAD:main

      - name: Health check (prod)
        env:
          HEROKU_APP: ${{ vars.HEROKU_APP_PROD }}
        run: |
          set -e
          BASE=$(heroku apps:info -a "$HEROKU_APP" | sed -n 's/^Web URL: *//p')
          BASE=${BASE%/}
          URL="${BASE}/api/v1/health"
          echo "Checking $URL"
          for i in {1..45}; do
            code=$(curl -s -o /dev/null -w "%{http_code}" "$URL" || true)
            if [ "$code" = "200" ]; then echo "Healthy ✅"; exit 0; fi
            sleep 2
          done
          echo "Health check failed ❌ (last code: $code) at $URL"; exit 1
