name: ci

on:
  push:
  pull_request:
  workflow_dispatch:

jobs:
  smoke:
    runs-on: ubuntu-latest

    services:
      mongo:
        image: mongo:6
        ports: ["27017:27017"]
        options: >-
          --health-cmd="mongosh --quiet --eval 'db.runCommand({ ping: 1 }).ok'"
          --health-interval=5s
          --health-timeout=5s
          --health-retries=20

    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Install deps (+ dev tools)
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install ruff black pip-audit

      - name: Compile sources (fast syntax check)
        run: python -m py_compile *.py || true

      - name: Wait for Mongo to be reachable
        run: |
          python - <<'PY'
          import time, sys
          from pymongo import MongoClient
          for _ in range(60):
              try:
                  MongoClient("mongodb://localhost:27017", serverSelectionTimeoutMS=1000).admin.command("ping")
                  print("Mongo is up")
                  sys.exit(0)
              except Exception:
                  time.sleep(1)
          print("Mongo did not come up", file=sys.stderr)
          sys.exit(1)
          PY

      - name: Smoke test with Flask test client (includes docs, validation, pagination)
        env:
          API_KEY: "ci-key"
          ALLOW_CLEAR: "true"
          MONGO_URI: "mongodb://localhost:27017"
          MONGO_DB: "cleancommute_ci"
          PYTHONPATH: ${{ github.workspace }}
        run: |
          python - <<'PY'
          import os, json, re
          os.environ.setdefault("API_KEY", os.getenv("API_KEY","ci-key"))
          os.environ.setdefault("ALLOW_CLEAR", os.getenv("ALLOW_CLEAR","true"))
          os.environ.setdefault("MONGO_URI", os.getenv("MONGO_URI","mongodb://localhost:27017"))
          os.environ.setdefault("MONGO_DB", os.getenv("MONGO_DB","cleancommute_ci"))

          from app import app
          c = app.test_client()

          def J(r):
              try:
                  return json.loads(r.data.decode("utf-8"))
              except Exception:
                  raise AssertionError(f"Non-JSON response: {r.status_code} {r.data[:200]!r}")

          def ok200(r): 
              assert r.status_code == 200, f"Expected 200, got {r.status_code}: {r.data[:200]!r}"

          def as_list_or_data(rjson):
              if isinstance(rjson, list): return rjson
              if isinstance(rjson, dict) and isinstance(rjson.get("data"), list): return rjson["data"]
              raise AssertionError(f"Expected list or {{'data': list}}, got: {rjson!r}")

          # Health (/api/v1/health preferred; fallback /health)
          r = c.get("/api/v1/health")
          if r.status_code == 404:
              r = c.get("/health")
          b = J(r); ok200(r); assert b.get("ok") in (True,1)

          # DB ping (200 or 500 is fine depending on test Mongo)
          r = c.get("/api/v1/db-ping"); _=J(r); assert r.status_code in (200,500)

          # ---- API Docs
          r = c.get("/openapi.json"); ok200(r); spec = J(r)
          assert spec.get("openapi","").startswith("3."), "OpenAPI version missing"
          r = c.get("/docs"); ok200(r); 
          assert b"redoc" in r.data.lower(), "Redoc page should include 'redoc'"

          # ---- Samples list (pagination fields exist)
          r = c.get("/api/v1/samples?limit=1&offset=0")
          b = J(r); ok200(r)
          assert "data" in b and "next_offset" in b and "has_more" in b

          # ---- Unauthorized create should be 401 with WWW-Authenticate
          r = c.post("/api/v1/samples", json={"name":"CI"})
          assert r.status_code == 401 and r.headers.get("WWW-Authenticate","").startswith("API-Key")

          # ---- Authorized create works
          headers={"x-api-key": os.environ["API_KEY"]}
          r = c.post("/api/v1/samples", json={"name":"CI", "meta":{"ci":True}}, headers=headers)
          b = J(r); assert r.status_code == 201 and isinstance(b.get("data",{}).get("_id",""), str)

          # ---- Commute validation: missing destination -> 400
          r = c.post("/api/v1/commutes", json={"origin":"A"}, headers=headers)
          assert r.status_code == 400, f"Expected 400 validation error, got {r.status_code}"
          bj = J(r); assert bj.get("error") == "bad_request"

          # ---- Commute validation: invalid mode -> 400
          r = c.post("/api/v1/commutes", json={"origin":"A","destination":"B","mode":"flying"}, headers=headers)
          assert r.status_code == 400

          # ---- Commute valid create -> 201
          r = c.post("/api/v1/commutes", json={"origin":"Home","destination":"Work","mode":"driving"}, headers=headers)
          b = J(r); assert r.status_code == 201 and isinstance(b.get("data",{}).get("_id",""), str)

          # ---- List commutes with pagination metadata
          r = c.get("/api/v1/commutes?limit=1&offset=0")
          b = J(r); ok200(r)
          assert "data" in b and isinstance(b["data"], list)
          assert "next_offset" in b and isinstance(b["next_offset"], int)
          assert "has_more" in b and isinstance(b["has_more"], bool)

          # ---- Clear endpoints (enabled in CI)
          r = c.post("/api/v1/commutes/clear", headers=headers); ok200(r)
          r = c.post("/api/v1/samples/clear",  headers=headers); ok200(r)

          print("✅ Smoke OK (docs, validation, pagination verified)")
          PY

      - name: Style (ruff + black autoformat)
        run: |
          ruff check .
          black .
          echo "✅ Style checks passed (Black autoformatted if needed)."

      - name: Vulnerability scan (pip-audit; non-blocking)
        run: pip-audit -r requirements.txt || true

  # ---- Staging deploy (unchanged) ----
  deploy_staging:
    name: Deploy to Heroku (staging)
    runs-on: ubuntu-latest
    needs: smoke
    if: github.event_name == 'push' && github.ref == 'refs/heads/staging'
    steps:
      - uses: actions/checkout@v4

      - name: Setup Heroku CLI
        uses: heroku/actions/setup@v2

      - name: Push code to Heroku (staging)
        uses: akhileshns/heroku-deploy@v4.2.1
        with:
          heroku_api_key: ${{ secrets.HEROKU_API_KEY }}
          heroku_app_name: ${{ vars.HEROKU_APP_STAGING }}
          heroku_email: ${{ secrets.HEROKU_EMAIL }}
          usedocker: false

      - name: (Optional) Set config vars (staging) if provided
        env:
          HEROKU_API_KEY: ${{ secrets.HEROKU_API_KEY }}
          HEROKU_APP: ${{ vars.HEROKU_APP_STAGING }}
          API_KEY: ${{ secrets.API_KEY_STAGING }}
          MONGO_URI: ${{ secrets.MONGO_URI_STAGING }}
          FRONTEND_ORIGIN: ${{ secrets.FRONTEND_ORIGIN_STAGING }}
          DEFAULT_LIMITS: ${{ secrets.DEFAULT_LIMITS }}
          LIMITER_STORAGE_URI: ${{ secrets.LIMITER_STORAGE_URI }}
        run: |
          heroku auth:whoami || true
          set_kv=""
          [ -n "$API_KEY" ] && set_kv="$set_kv API_KEY=$API_KEY"
          [ -n "$MONGO_URI" ] && set_kv="$set_kv MONGO_URI=$MONGO_URI"
          [ -n "$FRONTEND_ORIGIN" ] && set_kv="$set_kv FRONTEND_ORIGIN=$FRONTEND_ORIGIN"
          [ -n "$DEFAULT_LIMITS" ] && set_kv="$set_kv DEFAULT_LIMITS=$DEFAULT_LIMITS"
          [ -n "$LIMITER_STORAGE_URI" ] && set_kv="$set_kv LIMITER_STORAGE_URI=$LIMITER_STORAGE_URI"
          if [ -n "$set_kv" ]; then
            heroku config:set $set_kv -a "$HEROKU_APP"
          else
            echo "No config vars provided; skipping"
          fi

      - name: Health check (staging)
        run: |
          set -e
          URL="https://${{ vars.HEROKU_APP_STAGING }}.herokuapp.com/api/v1/health"
          echo "Checking $URL"
          for i in {1..30}; do
            code=$(curl -s -o /dev/null -w "%{http_code}" "$URL") || true
            if [ "$code" = "200" ]; then echo "Healthy ✅"; exit 0; fi
            sleep 2
          done
          echo "Health check failed ❌"; exit 1

  # ---- Production deploy (unchanged) ----
  deploy_prod:
    name: Deploy to Heroku (production)
    runs-on: ubuntu-latest
    needs: smoke
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    steps:
      - uses: actions/checkout@v4

      - name: Setup Heroku CLI
        uses: heroku/actions/setup@v2

      - name: Push code to Heroku (prod)
        uses: akhileshns/heroku-deploy@v4.2.1
        with:
          heroku_api_key: ${{ secrets.HEROKU_API_KEY }}
          heroku_app_name: ${{ vars.HEROKU_APP_PROD }}
          heroku_email: ${{ secrets.HEROKU_EMAIL }}
          usedocker: false

      - name: (Optional) Set config vars (prod) if provided
        env:
          HEROKU_API_KEY: ${{ secrets.HEROKU_API_KEY }}
          HEROKU_APP: ${{ vars.HEROKU_APP_PROD }}
          API_KEY: ${{ secrets.API_KEY_PROD }}
          MONGO_URI: ${{ secrets.MONGO_URI_PROD }}
          FRONTEND_ORIGIN: ${{ secrets.FRONTEND_ORIGIN_PROD }}
          DEFAULT_LIMITS: ${{ secrets.DEFAULT_LIMITS }}
          LIMITER_STORAGE_URI: ${{ secrets.LIMITER_STORAGE_URI }}
        run: |
          set_kv=""
          [ -n "$API_KEY" ] && set_kv="$set_kv API_KEY=$API_KEY"
          [ -n "$MONGO_URI" ] && set_kv="$set_kv MONGO_URI=$MONGO_URI"
          [ -n "$FRONTEND_ORIGIN" ] && set_kv="$set_kv FRONTEND_ORIGIN=$FRONTEND_ORIGIN"
          [ -n "$DEFAULT_LIMITS" ] && set_kv="$set_kv DEFAULT_LIMITS=$DEFAULT_LIMITS"
          [ -n "$LIMITER_STORAGE_URI" ] && set_kv="$set_kv LIMITER_STORAGE_URI=$LIMITER_STORAGE_URI"
          if [ -n "$set_kv" ]; then
            heroku config:set $set_kv -a "$HEROKU_APP"
          else
            echo "No config vars provided; skipping"
          fi

      - name: Health check (prod)
        run: |
          set -e
          URL="https://${{ vars.HEROKU_APP_PROD }}.herokuapp.com/api/v1/health"
          echo "Checking $URL"
          for i in {1..30}; do
            code=$(curl -s -o /dev/null -w "%{http_code}" "$URL") || true
            if [ "$code" = "200" ]; then echo "Healthy ✅"; exit 0; fi
            sleep 2
          done
          echo "Health check failed ❌"; exit 1
